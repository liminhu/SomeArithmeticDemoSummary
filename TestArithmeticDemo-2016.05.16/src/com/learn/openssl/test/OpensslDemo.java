package com.learn.openssl.test;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import sun.misc.BASE64Decoder;

public class OpensslDemo {
	public static String encrypt(String data, String key, String iv) {
		try {
			Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
			int blockSize = cipher.getBlockSize();

			byte[] dataBytes = data.getBytes();
			int plaintextLength = dataBytes.length;
			if (plaintextLength % blockSize != 0) {
				plaintextLength = plaintextLength
						+ (blockSize - (plaintextLength % blockSize));
			}

			byte[] plaintext = new byte[plaintextLength];
			System.arraycopy(dataBytes, 0, plaintext, 0, dataBytes.length);
			SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), "AES");
			IvParameterSpec ivSpec = new IvParameterSpec(iv.getBytes());

			cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
			byte[] encrypted = cipher.doFinal(plaintext);
			return new sun.misc.BASE64Encoder().encode(encrypted);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	public static byte[] hexStringToBytes(String hexString) {
		if (hexString == null || hexString.equals("")) {
			return null;
		}
		hexString = hexString.toUpperCase();
		int length = hexString.length() / 2;
		char[] hexChars = hexString.toCharArray();
		byte[] d = new byte[length];
		for (int i = 0; i < length; i++) {
			int pos = i * 2;
			d[i] = (byte) (charToByte(hexChars[pos]) << 4 | charToByte(hexChars[pos + 1]));
		}
		return d;
	}

	private static byte charToByte(char c) {
		return (byte) "0123456789ABCDEF".indexOf(c);
	}

	// char转byte
	private static byte[] getBytes(char[] chars) {
		Charset cs = Charset.forName("UTF-8");
		CharBuffer cb = CharBuffer.allocate(chars.length);
		cb.put(chars);
		cb.flip();
		ByteBuffer bb = cs.encode(cb);
		return bb.array();
	}

	public static String desEncrypt(String data, String key, String iv) {
		try {
			byte[] encrypted = new BASE64Decoder().decodeBuffer(data);
			// byte[] encrypted =getBytes(data);
			// 打印数据，测试
			char[] en = new char[encrypted.length];
			for (int i = 0; i < encrypted.length; i++) {
				en[i] = (char) (encrypted[i] & 0xFF);
			}
			resultOutPrint(en, 0x290);

			Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
			SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), "AES");
			IvParameterSpec ivSpec = new IvParameterSpec(iv.getBytes());
			cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
			byte[] original = cipher.doFinal(encrypted);
			String originalString = new String(original);
			return originalString;
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	private static int resultOutPrint(char[] out, int length) {
		for (int i = 0; i < length; i++) {
			if (i % 16 == 0 && i != 0)
				System.out.println("");
			System.out.format("%02x ", new Object[] { new Integer(out[i]) });
		}
		return 1;
	}

	private static int getKeyValue(StringBuilder builder, byte value, int i) {
		if (i % 2 != 0) {
			builder.append((char) value);
		} else {
			int high = value / 10;
			int low = value % 10;
			if (high > 0) {
				// high += 30;
				builder.append(high);
			}
			builder.append(low);
		}
		return 0;
	}

	public static void main(String[] args) {
		String testData = "Hello World!!!";
		char[] input = new char[] { 0x0B, 0x24, 0x0C, 0xD0, 0x61, 0x95, 0x82,
				0x19, 0x9B, 0xBC, 0xE4, 0x28, 0xBC, 0x70, 0x2C, 0xD4, 0x3B,
				0x40, 0x02, 0xE6, 0x9B, 0x57, 0x4C, 0x73, 0x6E, 0x2A, 0x72,
				0x37, 0x35, 0x97, 0x76, 0xDE, 0x00, 0x71, 0x6C, 0xC7, 0x2D,
				0x19, 0xF9, 0xFA, 0x00, 0x63, 0x76, 0x8F, 0x1F, 0xEB, 0xE3,
				0x7E, 0xD0, 0x0C, 0x42, 0xE2, 0x30, 0x20, 0xE9, 0x5C, 0x92,
				0x0B, 0xBB, 0xE9, 0x89, 0x87, 0xD9, 0x75, 0xD0, 0x22, 0x60,
				0x0F, 0xE7, 0x96, 0x5C, 0x89, 0xC0, 0x59, 0x8E, 0x2D, 0xE7,
				0x3E, 0x44, 0x0A, 0x7A, 0x21, 0xA0, 0x9C, 0x7D, 0x71, 0x46,
				0x7D, 0x28, 0xB9, 0x99, 0x57, 0x52, 0x01, 0x58, 0x3D, 0x36,
				0xDE, 0xE6, 0x9B, 0x87, 0x01, 0xB3, 0x17, 0xA2, 0xD6, 0x86,
				0xFE, 0xA8, 0x6B, 0x0C, 0xE1, 0x87, 0x60, 0x7B, 0xDE, 0x89,
				0x0B, 0xCD, 0x31, 0xAA, 0x4F, 0xCA, 0x93, 0xD9, 0xF1, 0x0E,
				0x3C, 0x43, 0xCE, 0xAE, 0xFA, 0x79, 0xE3, 0xD9, 0xF3, 0xAB,
				0x90, 0x45, 0xA2, 0xC8, 0x55, 0xF5, 0x64, 0x03, 0x7E, 0xAE,
				0x89, 0xBE, 0x6D, 0x58, 0x2F, 0x62, 0x22, 0x06, 0x56, 0x59,
				0x3C, 0x2B, 0xD1, 0x15, 0x80, 0x4F, 0x53, 0x5F, 0x56, 0x5C,
				0xE2, 0x4F, 0x9C, 0x8E, 0xAE, 0xAB, 0xFE, 0xD2, 0xA1, 0xF3,
				0xF0, 0x75, 0xB6, 0x77, 0x44, 0x5F, 0x8F, 0xA1, 0xCC, 0xFB,
				0x59, 0xEA, 0x4C, 0x02, 0xC4, 0xA8, 0x9A, 0xD8, 0x54, 0x08,
				0x35, 0xF6, 0xB7, 0x23, 0xE7, 0x2A, 0xFC, 0x19, 0xFC, 0x0A,
				0x85, 0x4A, 0x7F, 0xCB, 0xB4, 0x50, 0xEC, 0xD5, 0xE3, 0xB5,
				0xEA, 0x80, 0xF6, 0x98, 0x20, 0xF8, 0x38, 0xAF, 0xC1, 0xFD,
				0xCA, 0x2B, 0x92, 0x68, 0xB1, 0x79, 0x34, 0x1F, 0x21, 0x5D,
				0x53, 0x10, 0xDE, 0x5E, 0x8E, 0x52, 0xEC, 0x70, 0x7B, 0xAE,
				0x1C, 0x95, 0xB4, 0x6E, 0x1D, 0xAC, 0x8B, 0x62, 0xD7, 0xE2,
				0xF2, 0xD8, 0x68, 0xF7, 0x98, 0x50, 0xC9, 0xC7, 0x3C, 0x4E,
				0xD4, 0x76, 0x44, 0x70, 0x89, 0x76, 0x82, 0xAF, 0xAF, 0x24,
				0xF2, 0x35, 0xC3, 0xE0, 0xB4, 0x7B, 0x6A, 0xBC, 0x48, 0xB8,
				0x05, 0x40, 0x7F, 0x2E, 0x0F, 0x69, 0x1C, 0x70, 0x89, 0x88,
				0xD9, 0x39, 0xFA, 0x47, 0xA7, 0xDC, 0x1F, 0x61, 0x94, 0xAB,
				0xB2, 0xF2, 0x29, 0x03, 0x48, 0x76, 0x50, 0x3D, 0x65, 0xE4,
				0x2E, 0x61, 0x47, 0x50, 0x37, 0x94, 0xD0, 0x73, 0x48, 0x07,
				0xDC, 0x18, 0x61, 0x60, 0x59, 0xB6, 0x06, 0x0D, 0x13, 0x6F,
				0x31, 0xCD, 0xF8, 0x3D, 0x4C, 0xB5, 0xFD, 0x54, 0x24, 0xE2,
				0x87, 0x4A, 0xAD, 0x74, 0x25, 0x04, 0x81, 0xBE, 0xED, 0xB5,
				0x5F, 0xEC, 0x9C, 0x79, 0xAC, 0x1E, 0x34, 0x4F, 0x8B, 0x7F,
				0xE8, 0x41, 0x0D, 0x1B, 0x6E, 0x12, 0x97, 0x8E, 0xD0, 0x55,
				0x7A, 0xBF, 0xE3, 0xD1, 0x16, 0x91, 0xAE, 0x13, 0x6C, 0x16,
				0x6B, 0xC5, 0xCF, 0x92, 0x7D, 0xBB, 0x83, 0x12, 0x4F, 0x7B,
				0x02, 0x06, 0x91, 0x39, 0x96, 0x49, 0xD2, 0x4F, 0x7B, 0xBF,
				0x8A, 0x40, 0x2D, 0xCA, 0xB4, 0xC9, 0xCE, 0xD2, 0xCE, 0x45,
				0xA4, 0x95, 0xCE, 0xE6, 0xFE, 0x43, 0x52, 0x6C, 0x91, 0x86,
				0xFF, 0x25, 0x1E, 0x47, 0x30, 0x7E, 0xA5, 0xC6, 0x05, 0xCE,
				0x32, 0x56, 0xF9, 0x9C, 0x75, 0x58, 0x73, 0x39, 0x12, 0x6D,
				0x08, 0xF4, 0x00, 0xD5, 0xB1, 0x51, 0x2A, 0x36, 0x43, 0xC7,
				0xED, 0xBE, 0x2F, 0xCA, 0x6A, 0x60, 0x89, 0xE4, 0x41, 0x63,
				0x58, 0xDE, 0xA5, 0x61, 0xD9, 0x17, 0x53, 0x53, 0x5B, 0x90,
				0xB8, 0x42, 0xE5, 0x7C, 0x07, 0xA8, 0xD7, 0x9B, 0x3D, 0x6A,
				0x0B, 0x00, 0xCD, 0x47, 0x6A, 0x68, 0xF5, 0xAE, 0xBB, 0x05,
				0x82, 0x47, 0xC1, 0x0E, 0x2E, 0xD4, 0xBE, 0xDA, 0x44, 0x2F,
				0x2D, 0xC2, 0xD5, 0x2B, 0x49, 0x7E, 0x86, 0x9D, 0xD7, 0xEA,
				0xF6, 0xCE, 0x32, 0x3A, 0xB0, 0x04, 0xE7, 0xE3, 0x41, 0xDA,
				0x4E, 0xA9, 0xA3, 0x68, 0x38, 0x1D, 0xF7, 0x03, 0x7B, 0x71,
				0x1E, 0x68, 0x43, 0x60, 0x1E, 0xF4, 0xC1, 0x27, 0x61, 0x44,
				0x86, 0x6B, 0x33, 0xAD, 0xFB, 0x90, 0xB1, 0xCD, 0x5B, 0xDE,
				0x88, 0x79, 0x86, 0x12, 0x22, 0xDF, 0x17, 0x86, 0x14, 0xDA,
				0x52, 0x1B, 0xD2, 0xD5, 0x83, 0xDF, 0xE0, 0x27, 0xAB, 0x53,
				0xE6, 0x43, 0xAF, 0x16, 0x42, 0x2E, 0x4B, 0xB4, 0x0D, 0xAB,
				0xCF, 0x97, 0x46, 0x7B, 0x1F, 0xC4, 0x77, 0xDF, 0xEE, 0x91,
				0x9E, 0xF3, 0x49, 0x4C, 0xE8, 0xD3, 0x69, 0xAB, 0xA7, 0x42,
				0x0A, 0x3C, 0xA6, 0xE4, 0xF0, 0x0F, 0xDE, 0x16, 0x4A, 0xDE,
				0x43, 0xF4, 0x20, 0xDD, 0x20, 0x4D, 0x02, 0x9C, 0x73, 0x34,
				0x17, 0x81, 0xDB, 0x8C, 0x99, 0x47, 0x2E, 0x69, 0x03, 0xE8,
				0x3A, 0x12, 0xAE, 0x5D, 0xC3, 0xBE, 0x9D, 0x68, 0x50, 0x91,
				0xB9, 0xF0, 0x79, 0x56, 0xEF, 0x0F, 0x1C, 0x9D, 0x13 };
		// resultOutPrint(input,0x290);
		String plaintext = "CyQM0GGVghmbvOQovHAs1DtAAuabV0xzbipyNzWXdt4AcWzHLRn5+gBjdo8f6+N+0AxC4jAg6VySC7vpiYfZddAiYA/nllyJwFmOLec+RAp6IaCcfXFGfSi5mVdSAVg9Nt7mm4cBsxei1ob+qGsM4Ydge96JC80xqk/Kk9nxDjxDzq76eePZ86uQRaLIVfVkA36uib5tWC9iIgZWWTwr0RWAT1NfVlziT5yOrqv+0qHz8HW2d0Rfj6HM+1nqTALEqJrYVAg19rcj5yr8GfwKhUp/y7RQ7NXjteqA9pgg+Divwf3KK5JosXk0HyFdUxDeXo5S7HB7rhyVtG4drIti1+Ly2Gj3mFDJxzxO1HZEcIl2gq+vJPI1w+C0e2q8SLgFQH8uD2kccImI2Tn6R6fcH2GUq7LyKQNIdlA9ZeQuYUdQN5TQc0gH3BhhYFm2Bg0TbzHN+D1Mtf1UJOKHSq10JQSBvu21X+yceaweNE+Lf+hBDRtuEpeO0FV6v+PRFpGuE2wWa8XPkn27gxJPewIGkTmWSdJPe7+KQC3KtMnO0s5FpJXO5v5DUmyRhv8lHkcwfqXGBc4yVvmcdVhzORJtCPQA1bFRKjZDx+2+L8pqYInkQWNY3qVh2RdTU1uQuELlfAeo15s9agsAzUdqaPWuuwWCR8EOLtS+2kQvLcLVK0l+hp3X6vbOMjqwBOfjQdpOqaNoOB33A3txHmhDYB70wSdhRIZrM637kLHNW96IeYYSIt8XhhTaUhvS1YPf4CerU+ZDrxZCLku0DavPl0Z7H8R33+6RnvNJTOjTaaunQgo8puTwD94WSt5D9CDdIE0CnHM0F4HbjJlHLmkD6DoSrl3Dvp1oUJG58HlW7w8cnRM=";
		String imei = "359471060237567";
		String aaa = "7362135407032643";
		StringBuilder getKey = new StringBuilder();
		int i = 0;
		byte[] imeiByte = imei.getBytes();
		byte[] aaaByte = aaa.getBytes();
		for (i = 0; i < imei.length(); i++) {
			if (i % 2 == 0) {
				getKeyValue(getKey, (byte) (imeiByte[i] ^ aaaByte[i]), i);
			} else {
				if (i % 3 == 0) {
					getKeyValue(getKey, imeiByte[i], i);
				} else {
					getKeyValue(getKey, aaaByte[i], i);
				}
			}
		}
		String key = getKey.toString();
		System.out.println(key);
		String iv = key;
		String result = encrypt(testData, key, iv);
		System.out.println(result + "\n\n");
		System.out.println("\n\n" + desEncrypt(plaintext, key, iv));
	}

}

// http://my.oschina.net/jiangli0502/blog/171263